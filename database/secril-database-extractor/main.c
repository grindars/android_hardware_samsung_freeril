/*
 * Free RIL implementation for Samsung Android-based smartphones.
 * Copyright (C) 2012  Sergey Gridasov <grindars@gmail.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <stdio.h>
#include <getopt.h>
#include <string.h>
#include <stdlib.h>

#include "arm_dl.h"

typedef struct {
    unsigned char mccmnc[6];
    const char *long_name;
    const char *short_name;
} operator_name_t;

static void usage(const char *application) {
    printf(
        "Usage: %s [OPTION]...\n"
        "Extracts operator table from the proprietary sec-ril.\n\n"
        "Mandatory arguments to long options are mandatory for short options too.\n"
        "  -i, --input=<FILE>  use specified file as the library image.\n"
        "  -o, --output=<FILE> write SQL to specified file.\n"
        "  --version           print version information and exit.\n"
        "  --help              print this message and exit.\n", application
    );
}

static void version(void) {
    puts("secril-database-extractor 1.0");
}

static int parse_cmdline(int argc, char *argv[], char **filename, char **output_filename) {
    static const struct option options[] = {
        { .name = "help",    .has_arg = no_argument,       .flag = NULL, .val = 0   },
        { .name = "version", .has_arg = no_argument,       .flag = NULL, .val = 0   },
        { .name = "input",   .has_arg = required_argument, .flag = NULL, .val = 'i' },
        { .name = "output",  .has_arg = required_argument, .flag = NULL, .val = 'o' }
    };

    int ch, longidx;

    *filename = NULL;
    *output_filename = NULL;

    while((ch = getopt_long(argc, argv, "i:o:", options, &longidx)) != -1) {
        switch(ch) {
            case '?':
            case ':':
                return 0;

            case 'i':
                *filename = optarg;

                break;

            case 'o':
                *output_filename = optarg;

                break;

            case 0:
                switch(longidx) {
                    case 0:
                        usage(argv[0]);

                        return 0;

                    case 1:
                        version();

                        return 0;
                }

                break;
        }
    }

    if(*filename == NULL) {
        fprintf(stderr, "%1$s: RIL file name is not specified. Try '%1$s --help'.\n", argv[0]);

        return 0;
    }

    if(*output_filename == NULL) {
        fprintf(stderr, "%1$s: output file name is not specified. Try '%1$s --help'.\n", argv[0]);

        return 0;
    }


    return 1;
}

static char *escape(const char *string) {
    size_t len = strlen(string) + 1;
    char *dup = malloc(len);
    memcpy(dup, string, len);

    char *searchptr = dup;

    while(1) {
        char *badchr = strchr(searchptr, '\'');

        if(badchr == NULL)
            break;

        ssize_t diff = searchptr - dup;
        ssize_t pos = badchr - dup;
        len++;
        dup = realloc(dup, len);
        searchptr = dup + diff;
        badchr = dup + pos;

        memmove(badchr + 1, badchr, len - pos - 1);

        searchptr = badchr + 2;
    }

    return dup;
}

int main(int argc, char *argv[]) {
    char *filename, *output_filename;
    void *base, *dynamic;
    size_t size;

    if(!parse_cmdline(argc, argv, &filename, &output_filename))
        return 1;

    arm_dlhandle_t *handle = arm_dlopen(filename);

    if(handle == NULL) {
        perror("arm_dlopen");

        return 1;
    }

    void *table = arm_dlsym(handle, "opname_list");
    void *table_end = arm_dlsym(handle, "TimezoneIdList");

    if(table == NULL || table_end == NULL) {
        fputs("opname_list not found\n", stderr);

        arm_dlclose(handle);

        return 1;
    }

    FILE *output = fopen(output_filename, "w");
    if(output == NULL) {
        perror("fopen");

        arm_dlclose(handle);

        return 1;
    }

    fputs("-- Generated by the secril-database-extractor.\n\n"
          "BEGIN TRANSACTION;\n"
          "DROP TABLE IF EXISTS operators;\n"
          "CREATE TABLE operators (\n"
          "    mccmnc VARCHAR(6) PRIMARY KEY,\n"
          "    long_name VARCHAR(32),\n"
          "    short_name VARCHAR(32)\n"
          ");\n", output);

    operator_name_t *p;

    for(p = table; p < (operator_name_t *) table_end; p++) {
        char mccmnc[7];
        memcpy(mccmnc, p->mccmnc, 6);
        mccmnc[6] = 0;

        const char *raw_long_name = p->long_name ? p->long_name : "";
        const char *raw_short_name = p->short_name ? p->short_name : "";

        if(raw_long_name[0] == 0 && raw_short_name[0] == 0)
            continue;
        else if(raw_long_name[0] == 0)
            raw_long_name = raw_short_name;
        else if(raw_short_name[0] == 0)
            raw_short_name = raw_long_name;

        char *long_name = escape(raw_long_name);
        char *short_name = escape(raw_short_name);

        fprintf(output, "INSERT OR REPLACE INTO operators (mccmnc, long_name, short_name) VALUES ('%s', '%s', '%s');\n",
                mccmnc, long_name, short_name);

        free(short_name);
        free(long_name);
    }

    fputs("COMMIT;\n", output);
    fclose(output);

    arm_dlclose(handle);

    return 0;
}

